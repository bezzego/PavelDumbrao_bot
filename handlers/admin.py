from aiogram import Router, types
from aiogram.filters import Command
from aiogram.filters import StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
import config
import db.db as db
from keyboards import admin_menu
import asyncio
from aiogram import exceptions


router = Router()


# Define FSM state for broadcast
class AdminForm(StatesGroup):
    broadcast = State()


@router.message(Command("admin"))
async def cmd_admin(message: types.Message, state: FSMContext):
    if message.from_user.id not in config.ADMIN_IDS:
        await message.answer("‚õîÔ∏è –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        return
    # Clear any admin state (in case they were in middle of broadcast)
    await state.clear()
    # Send admin menu
    await message.answer("‚öôÔ∏è –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", reply_markup=admin_menu.admin_menu)


@router.callback_query(lambda c: c.data == "admin_stats")
async def admin_stats_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    total_users = db.get_user_count()
    premium_users = db.get_premium_count()
    referral_count = db.get_referral_count()
    # Optionally total points (sum of all user points)
    cur = db.conn.cursor()
    cur.execute("SELECT SUM(points) FROM users")
    total_points = cur.fetchone()[0] or 0
    text = (
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
        f"–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}\n"
        f"–ü—Ä–µ–º–∏—É–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {premium_users}\n"
        f"–ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ –ø–æ —Ä–µ—Ñ–µ—Ä–∞–ª–∞–º: {referral_count}\n"
        f"–°—É–º–º–∞—Ä–Ω–æ –±–∞–ª–ª–æ–≤ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_points}"
    )
    await callback.answer()
    await callback.message.answer(text)


@router.callback_query(lambda c: c.data == "admin_broadcast")
async def admin_broadcast_callback(callback: types.CallbackQuery, state: FSMContext):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    await callback.answer()
    # Prompt for broadcast message
    await callback.message.answer(
        "‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º:"
    )
    # Set FSM state to broadcast
    await state.set_state(AdminForm.broadcast)


@router.message(StateFilter(AdminForm.broadcast))
async def process_broadcast_message(message: types.Message, state: FSMContext):
    # Only admins should reach here, but double-check
    if message.from_user.id not in config.ADMIN_IDS:
        return
    # Get all user IDs
    cur = db.conn.cursor()
    cur.execute("SELECT user_id FROM users")
    users = [row[0] for row in cur.fetchall()]
    if not users:
        await message.answer("‚ùóÔ∏è –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.")
        await state.clear()
        return
    await message.answer(f"‚åõ –û—Ç–ø—Ä–∞–≤–ª—è—é —Å–æ–æ–±—â–µ–Ω–∏–µ {len(users)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º...")
    success = 0
    fail = 0
    for i, uid in enumerate(users):
        try:
            await message.copy_to(uid)
            success += 1
        except exceptions.TelegramForbiddenError:
            fail += 1
            # The user blocked the bot or left - optionally remove from DB
            db.delete_user(uid)
        except exceptions.TelegramFloodWait as e:
            # If hit flood limit, wait and continue
            await asyncio.sleep(e.retry_after)
            try:
                await message.copy_to(uid)
                success += 1
            except Exception:
                fail += 1
        except Exception:
            fail += 1
        # Throttle sending to avoid hitting flood limits
        if i % 20 == 0:
            await asyncio.sleep(0.5)
    await message.answer(
        f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –£—Å–ø–µ—à–Ω–æ: {success}, –Ω–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {fail}."
    )
    # Reset state
    await state.clear()


@router.callback_query(lambda c: c.data == "admin_send_pdf")
async def admin_send_pdf_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    await callback.answer()
    # Get all user IDs
    cur = db.conn.cursor()
    cur.execute("SELECT user_id FROM users")
    users = [row[0] for row in cur.fetchall()]
    if not users:
        await callback.message.answer("–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ PDF.")
        return
    await callback.message.answer(
        f"‚åõ –û—Ç–ø—Ä–∞–≤–∫–∞ PDF —Ñ–∞–π–ª–∞ {len(users)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º..."
    )
    success = 0
    fail = 0
    from aiogram.types import FSInputFile

    doc = FSInputFile("gift.pdf")
    for i, uid in enumerate(users):
        try:
            await callback.message.chat.bot.send_document(uid, doc)
            success += 1
        except exceptions.TelegramForbiddenError:
            fail += 1
            db.delete_user(uid)
        except exceptions.TelegramFloodWait as e:
            await asyncio.sleep(e.retry_after)
            try:
                await callback.message.chat.bot.send_document(uid, doc)
                success += 1
            except Exception:
                fail += 1
        except Exception:
            fail += 1
        if i % 10 == 0:
            await asyncio.sleep(1)
    await callback.message.answer(
        f"‚úÖ PDF –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω. –£—Å–ø–µ—à–Ω–æ: {success}, –Ω–µ —É–¥–∞–ª–æ—Å—å: {fail}."
    )


@router.callback_query(lambda c: c.data == "admin_reset_top")
async def admin_reset_top_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    # Reset all points to zero
    cur = db.conn.cursor()
    cur.execute("UPDATE users SET points = 0")
    db.conn.commit()
    await callback.answer("–¢–æ–ø —É—Å–ø–µ—à–Ω–æ —Å–±—Ä–æ—à–µ–Ω.", show_alert=True)
    await callback.message.answer("üèÜ –¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ –æ–±–Ω—É–ª–µ–Ω–∞.")


@router.callback_query(lambda c: c.data == "admin_export_csv")
async def admin_export_csv_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    await callback.answer()
    # Export users data to CSV
    import csv

    filename = "users_export.csv"
    cur = db.conn.cursor()
    cur.execute(
        "SELECT user_id, username, first_name, last_name, points, premium, invited_by, challenge_progress FROM users"
    )
    rows = cur.fetchall()
    with open(filename, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(
            [
                "user_id",
                "username",
                "first_name",
                "last_name",
                "points",
                "premium",
                "invited_by",
                "challenge_progress",
            ]
        )
        for row in rows:
            writer.writerow(
                [
                    row[0],
                    row[1] or "",
                    row[2] or "",
                    row[3] or "",
                    row[4],
                    row[5],
                    row[6] or "",
                    row[7],
                ]
            )
    # Send the CSV file to admin
    from aiogram.types import FSInputFile

    doc = FSInputFile(filename, filename=filename)
    await callback.message.answer_document(
        doc, caption="üìÑ –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"
    )


# List users command for admins
@router.message(Command("listusers"))
async def cmd_list_users(message: types.Message):
    if message.from_user.id not in config.ADMIN_IDS:
        return
    cur = db.conn.cursor()
    cur.execute("SELECT user_id, username, first_name, last_name FROM users")
    rows = cur.fetchall()
    if not rows:
        await message.reply("–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç.")
        return
    text = "üìã –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n\n"
    for r in rows:
        uid = r["user_id"]
        uname = r["username"]
        first = r["first_name"] or ""
        last = r["last_name"] or ""
        if first or last:
            full_name = f"{first} {last}".strip()
        else:
            full_name = "‚Äî"
        if uname:
            display_name = f"@{uname}"
        else:
            display_name = "‚Äî"
        text += f"‚Ä¢ `{uid}` ‚Äî {display_name} ({full_name})\n"
    await message.reply(text, parse_mode="Markdown")


@router.callback_query(lambda c: c.data and c.data.startswith("story_accept"))
async def story_accept_callback(callback: types.CallbackQuery):
    # Accept story screenshot (grant points)
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    # Parse user_id from callback data
    try:
        target_id = int(callback.data.split(":")[1])
    except:
        await callback.answer("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
        return
    # Check if user already submitted story
    if db.has_submitted_story(target_id):
        await callback.answer(
            "–≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª —Å—Ç–æ—Ä–∏—Å.", show_alert=True
        )
        return
    # Award points
    db.update_points(target_id, 50)
    db.mark_story_submitted(target_id)
    # Edit the original message in admin group to mark accepted
    try:
        new_caption = (callback.message.caption or "") + " ‚úÖ –ü—Ä–∏–Ω—è—Ç–æ"
        await callback.message.edit_caption(new_caption)
    except:
        # If cannot edit caption, remove keyboard at least
        try:
            await callback.message.edit_reply_markup(reply_markup=None)
        except:
            pass
    await callback.answer("–ü—Ä–∏–Ω—è—Ç–æ ‚úÖ")
    # Notify the user in private
    try:
        await callback.message.chat.bot.send_message(
            target_id, "‚úÖ –í–∞—à —Å—Ç–æ—Ä–∏—Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω! –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ 50 –±–∞–ª–ª–æ–≤."
        )
    except:
        pass


@router.callback_query(lambda c: c.data and c.data.startswith("story_reject"))
async def story_reject_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    try:
        target_id = int(callback.data.split(":")[1])
    except:
        await callback.answer("–û—à–∏–±–∫–∞", show_alert=True)
        return
    # Remove the inline buttons from the message (mark as processed)
    try:
        new_caption = (callback.message.caption or "") + " ‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ"
        await callback.message.edit_caption(new_caption)
    except:
        try:
            await callback.message.edit_reply_markup(reply_markup=None)
        except:
            pass
    await callback.answer("–û—Ç–∫–ª–æ–Ω–µ–Ω–æ")
    # Notify user about rejection
    try:
        await callback.message.chat.bot.send_message(
            target_id,
            "‚ùå –í–∞—à —Å—Ç–æ—Ä–∏—Å –Ω–µ –ø—Ä–∏–Ω—è—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ —É—Ç–æ—á–Ω–∏—Ç–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è.",
        )
    except:
        pass


@router.message(Command("setpremium"))
async def cmd_set_premium(message: types.Message):
    if message.from_user.id not in config.ADMIN_IDS:
        await message.bot.send_message(message.chat.id, "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞")
        return
    parts = message.text.split()
    if len(parts) != 3 or parts[1].isdigit() is False or parts[2] not in ("0", "1"):
        await message.bot.send_message(
            message.chat.id, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /setpremium <user_id> <0 –∏–ª–∏ 1>"
        )
        return
    user_id = int(parts[1])
    premium_flag = bool(int(parts[2]))
    db.set_premium(user_id, premium_flag)
    await message.bot.send_message(
        message.chat.id,
        f"–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} premium —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ {int(premium_flag)}.",
    )
    # Notify affected user
    try:
        if premium_flag:
            await message.bot.send_message(user_id, "üéâ –í–∞–º –≤—ã–¥–∞–Ω –ø—Ä–µ–º–∏—É–º-–¥–æ—Å—Ç—É–ø!")
        else:
            await message.bot.send_message(user_id, "‚ÑπÔ∏è –í–∞—à –ø—Ä–µ–º–∏—É–º-–¥–æ—Å—Ç—É–ø –±—ã–ª —Å–Ω—è—Ç.")
    except Exception:
        pass


@router.message(Command("setpoints"))
async def cmd_set_points(message: types.Message):
    if message.from_user.id not in config.ADMIN_IDS:
        await message.bot.send_message(message.chat.id, "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞")
        return
    parts = message.text.split()
    if (
        len(parts) != 3
        or parts[1].isdigit() is False
        or parts[2].lstrip("-").isdigit() is False
    ):
        await message.bot.send_message(
            message.chat.id, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /setpoints <user_id> <points>"
        )
        return
    user_id = int(parts[1])
    points = int(parts[2])
    db.set_points(user_id, points)
    await message.bot.send_message(
        message.chat.id,
        f"–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞–ª–ª–æ–≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –≤ {points}.",
    )
    # Notify affected user
    try:
        await message.bot.send_message(
            user_id, f"üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å –±–∞–ª–ª–æ–≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ {points}!"
        )
    except Exception:
        pass


@router.message(Command("ban"))
async def cmd_ban_user(message: types.Message):
    if message.from_user.id not in config.ADMIN_IDS:
        await message.bot.send_message(message.chat.id, "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞")
        return
    parts = message.text.split()
    if len(parts) != 2 or parts[1].isdigit() is False:
        await message.bot.send_message(message.chat.id, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /ban <user_id>")
        return
    user_id = int(parts[1])
    db.ban_user(user_id)
    await message.bot.send_message(
        message.chat.id, f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω."
    )
    # Notify affected user
    try:
        await message.bot.send_message(
            user_id, "‚õîÔ∏è –í—ã –±—ã–ª–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
        )
    except Exception:
        pass


@router.message(Command("unban"))
async def cmd_unban_user(message: types.Message):
    if message.from_user.id not in config.ADMIN_IDS:
        await message.bot.send_message(message.chat.id, "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞")
        return
    parts = message.text.split()
    if len(parts) != 2 or parts[1].isdigit() is False:
        await message.bot.send_message(
            message.chat.id, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /unban <user_id>"
        )
        return
    user_id = int(parts[1])
    db.unban_user(user_id)
    await message.bot.send_message(
        message.chat.id, f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω."
    )
    # Notify affected user
    try:
        await message.bot.send_message(
            user_id, "‚úÖ –í—ã –±—ã–ª–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
        )
    except Exception:
        pass


# New callback handlers for admin menu buttons


@router.callback_query(lambda c: c.data == "admin_listusers")
async def admin_listusers_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    await callback.answer()
    # Call the same logic as /listusers command
    cur = db.conn.cursor()
    cur.execute("SELECT user_id, username, first_name, last_name FROM users")
    rows = cur.fetchall()
    if not rows:
        await callback.message.answer("–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç.")
        return
    text = "üìã –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n\n"
    for r in rows:
        uid = r["user_id"]
        uname = r["username"]
        first = r["first_name"] or ""
        last = r["last_name"] or ""
        if first or last:
            full_name = f"{first} {last}".strip()
        else:
            full_name = "‚Äî"
        if uname:
            display_name = f"@{uname}"
        else:
            display_name = "‚Äî"
        text += f"‚Ä¢ `{uid}` ‚Äî {display_name} ({full_name})\n"
    await callback.message.answer(text, parse_mode="Markdown")


@router.callback_query(lambda c: c.data == "admin_setpremium")
async def admin_setpremium_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    await callback.answer()
    await callback.message.answer(
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/setpremium <user_id> <0 –∏–ª–∏ 1>` –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–µ–º–∏—É–º —Å—Ç–∞—Ç—É—Å–∞.",
        parse_mode="Markdown",
    )


@router.callback_query(lambda c: c.data == "admin_setpoints")
async def admin_setpoints_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    await callback.answer()
    await callback.message.answer(
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/setpoints <user_id> <points>` –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –±–∞–ª–ª–æ–≤.",
        parse_mode="Markdown",
    )


@router.callback_query(lambda c: c.data == "admin_ban")
async def admin_ban_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    await callback.answer()
    await callback.message.answer(
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/ban <user_id>` –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
        parse_mode="Markdown",
    )


@router.callback_query(lambda c: c.data == "admin_unban")
async def admin_unban_callback(callback: types.CallbackQuery):
    if callback.from_user.id not in config.ADMIN_IDS:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    await callback.answer()
    await callback.message.answer(
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/unban <user_id>` –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
        parse_mode="Markdown",
    )
